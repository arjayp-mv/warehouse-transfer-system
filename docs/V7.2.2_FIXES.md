# V7.2.2 Burnaby Under-Forecasting Fixes

**Date**: October 19, 2025
**Status**: COMPLETED
**Impact**: Critical - Fixes warehouse-specific forecasting accuracy

---

## Summary

V7.2.2 addresses THREE critical issues discovered during Burnaby warehouse forecasting:

1. Seasonal factors ignored warehouse parameter (all warehouses used combined data)
2. Historical comparison UI showed combined data for warehouse-specific forecasts
3. Forecast runs table sorted dates alphabetically instead of chronologically

---

## Issue 1: Seasonal Factor Calculation Ignored Warehouse Parameter

### Root Cause
`backend/seasonal_calculator.py:55-65` hardcoded combined warehouse sales data even when calculating seasonal factors for Burnaby or Kentucky warehouses:

```python
# WRONG CODE (before fix):
query = """
    SELECT `year_month`,
           CAST(SUBSTRING(`year_month`, 6, 2) AS UNSIGNED) as month,
           burnaby_sales + kentucky_sales as total_sales  # <- ALWAYS COMBINED!
    FROM monthly_sales
    WHERE sku_id = %s ...
"""
```

### Impact
- Burnaby forecasts used seasonal patterns from COMBINED business (Burnaby + Kentucky)
- Kentucky forecasts had the same problem
- Warehouse-specific forecasts were inaccurate because seasonal patterns differ by warehouse

### Example
For UB-YTX14-BS (motorcycle battery):
- **Combined**: Feb is low (0.62 factor), Apr-Jun is high (peak season)
- **Burnaby only**: Different pattern due to regional weather/demand
- **Result**: Burnaby forecast was using wrong seasonal curve

### Fix
Modified `backend/seasonal_calculator.py:54-74` to respect warehouse parameter:

```python
# CORRECT CODE (after fix):
if warehouse == 'combined':
    sales_column = 'corrected_demand_burnaby + corrected_demand_kentucky'
    where_clause = '(corrected_demand_burnaby > 0 OR corrected_demand_kentucky > 0)'
else:
    sales_column = f'corrected_demand_{warehouse}'
    where_clause = f'corrected_demand_{warehouse} > 0'

query = f"""
    SELECT `year_month`,
           CAST(SUBSTRING(`year_month`, 6, 2) AS UNSIGNED) as month,
           {sales_column} as total_sales
    FROM monthly_sales
    WHERE sku_id = %s
      AND `year_month` >= %s
      AND {where_clause}
    ORDER BY `year_month`
"""
```

### Verification
After fix, seasonal factors are now calculated correctly:
- Burnaby forecasts use Burnaby historical data
- Kentucky forecasts use Kentucky historical data
- Combined forecasts use combined data

---

## Issue 2: Historical Comparison Showed Wrong Data

### Root Cause
`backend/forecasting_api.py:583` hardcoded combined sales when fetching historical data for comparison:

```python
# WRONG CODE (before fix):
history_query = """
    SELECT `year_month`,
           burnaby_sales + kentucky_sales as total_sales,  # <- ALWAYS COMBINED!
           ...
"""
```

### Impact
User saw confusing comparisons:
- Burnaby forecast: 545 units
- Historical display: 923 units (actually combined 438 Burnaby + 485 Kentucky)
- **Appeared to be 41% under-forecast but was actually comparing apples to oranges!**

### Fix
Modified `backend/forecasting_api.py:548-607` to query warehouse from forecast_runs and use matching historical data:

```python
# CORRECT CODE (after fix):
# Get warehouse from forecast run
warehouse_query = """
    SELECT created_at, warehouse
    FROM forecast_runs
    WHERE id = %s
"""
warehouse = forecast_result[0]['warehouse'] if forecast_result else 'combined'

# Build warehouse-specific query
if warehouse == 'combined':
    sales_column = 'burnaby_sales + kentucky_sales'
    revenue_column = '(burnaby_sales + kentucky_sales) * s.cost_per_unit'
else:
    sales_column = f'{warehouse}_sales'
    revenue_column = f'{warehouse}_sales * s.cost_per_unit'

history_query = f"""
    SELECT `year_month`,
           {sales_column} as total_sales,
           {revenue_column} as total_revenue
    FROM monthly_sales ms
    JOIN skus s ON ms.sku_id = s.sku_id
    WHERE ms.sku_id = %s ...
"""
```

### Verification
Now historical comparison shows correct data:
- Burnaby forecast (545) vs Burnaby historical (438) = +24% growth
- Combined forecast vs Combined historical
- Kentucky forecast vs Kentucky historical

---

## Issue 3: Forecast Runs Table Sorted Dates Alphabetically

### Root Cause
`frontend/forecasting.js:44` rendered dates as strings, so DataTables sorted them alphabetically:

```
"10/19/2025, 1:58:42 AM"  <- came before (alphabetically)
"10/19/2025, 1:47:27 PM"  <- even though this is later!
```

### Impact
- Newest forecasts didn't appear at top of table
- Confusing UX - user couldn't find their latest forecast easily

### Fix
Modified `frontend/forecasting.js:44-53` to use dual-mode rendering:

```javascript
// CORRECT CODE (after fix):
{
    data: 'created_at',
    render: function(data, type, row) {
        // Use raw ISO timestamp for sorting, formatted date for display
        if (type === 'sort' || type === 'type') {
            return data || '';  // ISO timestamp sorts correctly
        }
        return renderDate(data);  // Pretty format for display
    }
}
```

### Verification
Now table sorts correctly by actual timestamp:
1. burnaby test3 (10/19/2025, 1:47:27 PM) ← Latest first
2. V7.2.2 Burnaby Fix Test (10/19/2025, 1:45:02 PM)
3. Kentucky Test (10/19/2025, 1:58:42 AM)
4. ...etc

**Note**: Browser cache may show old version. Hard refresh (Ctrl+Shift+R) or clear cache to see fix.

---

## Files Modified

1. **backend/seasonal_calculator.py** (lines 54-74)
   - Added warehouse-aware seasonal factor calculation

2. **backend/forecasting_api.py** (lines 548-607)
   - Added warehouse detection from forecast_runs
   - Dynamic SQL query based on warehouse

3. **frontend/forecasting.js** (lines 44-53)
   - Dual-mode render function for proper timestamp sorting

---

## Testing Results

### Test 1: Seasonal Factors Now Warehouse-Specific ✓
- Run #15 (Burnaby): Uses Burnaby seasonal patterns
- Run #16 (Burnaby test3): Uses Burnaby seasonal patterns
- Combined forecasts: Use combined patterns

### Test 2: Historical Comparison Now Accurate ✓
**UB-YTX14-BS Burnaby Forecast Comparison:**
```
Month     | Burnaby Forecast | Burnaby Historical | Difference
----------|------------------|--------------------|-----------
Feb 2026  | 545 units        | 438 units (Feb 25) | +24%
Mar 2026  | 710 units        | 681 units (Mar 25) | +4%
Apr 2026  | 1,283 units      | 974 units (Apr 25) | +32%
```

Previously showed COMBINED historical (923 for Feb = 438 Burnaby + 485 Kentucky)

### Test 3: Table Sorting Fixed ✓
Forecast runs now sort by actual timestamp (descending):
- Latest forecasts appear first
- Correct chronological order

---

## Business Impact

### Before V7.2.2
- Warehouse-specific forecasts were unreliable
- Users saw confusing comparison data
- Hard to find latest forecasts in UI

### After V7.2.2
- Accurate warehouse-specific seasonal patterns
- Clear apples-to-apples comparisons
- Better UX for forecast management

---

## Related Fixes

This builds on:
- **V7.2**: Fixed month calculation using relativedelta
- **V7.2.1**: Fixed database connection pool race condition

---

## Next Steps

Future enhancements could include:
1. Warehouse indicator in historical comparison chart title
2. Visual diff highlighting between forecast and historical
3. Configurable date format in table (user preference)

---

## Deployment Notes

1. Server auto-reloads when backend files change (uvicorn --reload)
2. Frontend JavaScript may be browser-cached - users should hard refresh
3. No database migrations required
4. No breaking API changes

---

**Author**: Claude Code
**Version**: V7.2.2
**Timestamp**: 2025-10-19 13:45:00
